# plsql-window-functions-Niyonkuru-nyirimpeta-yabesi

# PL/SQL Window Functions – Agribusiness Project

##  Project Overview
This project demonstrates the use of **PL/SQL window functions** to analyze sales data in an **agriculture/agribusiness company**.  
The objective is to apply **ranking, aggregation, navigation, and distribution functions** to discover top customers, sales trends, and customer segmentation insights.  

---

##  Business Problem
**Context**: Agribusiness operating across regions in Rwanda.  
**Challenge**: The company does not know the **top-selling agricultural products** in each region.  
**Expected Outcome**: By applying SQL window functions, the company can identify top products, track monthly revenue growth, and segment customers for marketing strategies.  

---

##  Success Criteria
1. Identify **Top customers by revenue** → `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`, `PERCENT_RANK()`.  
2. Compute **running totals and averages** → `SUM()`, `AVG()`.  
3. Track **minimum and maximum sales trends** → `MIN()`, `MAX()`.  
4. Compare **previous vs next transactions** → `LAG()`, `LEAD()`.  
5. Segment customers into **quartiles and distributions** → `NTILE(4)`, `CUME_DIST()`.  

---

##  Database Schema
```sql
CREATE DATABASE agriculture;

CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    cust_name VARCHAR(50),
    region VARCHAR(30)
);

CREATE TABLE products (
    product_id INT PRIMARY KEY,
    prod_name VARCHAR(50),
    category VARCHAR(40)
);

CREATE TABLE transactions (
    transaction_id INT PRIMARY KEY,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    product_id INT,
    FOREIGN KEY (product_id) REFERENCES products(product_id),
    sale_date DATE,
    amount DECIMAL(10,2)
);
```

DATA INSERTION

1. CUSTOMERS TABLE
```SQL
INSERT INTO customers VALUES (1, 'Yabesi', 'Musanze');
INSERT INTO customers VALUES (2, 'Niyonkuru', 'Rubavu');
INSERT INTO customers VALUES (3, 'Nyirimpeta', 'Gasabo');
INSERT INTO customers VALUES (4, 'Rukundo', 'Kicukiro');
INSERT INTO customers VALUES (5, 'Shema', 'Nyabihu');
INSERT INTO customers VALUES (6, 'Ruterana', 'Nyabihu');
INSERT INTO customers VALUES (7, 'Iduhorahafi', 'Remera');
INSERT INTO customers VALUES (8, 'Niyomugaba', 'Kimironko');
INSERT INTO customers VALUES (9, 'Uwase', 'Rubavu');
INSERT INTO customers VALUES (10, 'Uwera', 'Gakenke');
```
![My Project Screenshot](/screenshots/customers.png)

2. PRODUCTS TABLE
```sql
INSERT INTO products VALUES (1, 'Beans', 'Legumes');
INSERT INTO products VALUES (2, 'Oranges', 'Fruits');
INSERT INTO products VALUES (3, 'Carrots', 'Vegetables');
INSERT INTO products VALUES (4, 'Coffee', 'Cash Crops');
INSERT INTO products VALUES (5, 'Milk', 'Livestock');
INSERT INTO products VALUES (6, 'Flowers', 'Horticulture');
INSERT INTO products VALUES (7, 'Tea', 'Cash Crops');
INSERT INTO products VALUES (8, 'Onions', 'Vegetables');
INSERT INTO products VALUES (9, 'Bananas', 'Fruits');
INSERT INTO products VALUES (10, 'Rice', 'Cereals');
```
![My Project Screenshot](/screenshots/products.png)

3.TRANSACTIONS TABLE
```SQL
INSERT INTO transactions VALUES (1, 1, 1, '2025-01-03', 12000);
INSERT INTO transactions VALUES (2, 3, 4, '2025-04-13', 12400);
INSERT INTO transactions VALUES (3, 5, 7, '2025-05-09', 17800);
INSERT INTO transactions VALUES (4, 8, 2, '2025-09-09', 20000);
INSERT INTO transactions VALUES (5, 9, 8, '2025-07-03', 25000);
INSERT INTO transactions VALUES (6, 5, 4, '2025-02-20', 27000);
INSERT INTO transactions VALUES (7, 1, 9, '2025-03-15', 10000);
INSERT INTO transactions VALUES (8, 4, 8, '2025-01-10', 8000);
INSERT INTO transactions VALUES (9, 10, 1, '2025-01-10', 8000);
INSERT INTO transactions VALUES (10, 10, 10, '2025-10-10', 100000);
```
![My Project Screenshot](/screenshots/transactions1.png)

WINDOW FUNCTION IMPLEMENTATION

1. Ranking Functions
```sql
--row_number(),
SELECT customer_id,
       SUM(amount) AS total_revenue,
       ROW_NUMBER() OVER (ORDER BY SUM(amount) DESC) AS row_num
FROM transactions
GROUP BY customer_id
ORDER BY total_revenue DESC;
-- The above query calculates the total revenue generated by each customer and assigns a unique row number to each customer based on their total revenue in descending order.
```
![My Project Screenshot](/screenshots/row_number.png)

```sql
--rank(),

SELECT customer_id,
       SUM(amount) AS total_revenue,
       RANK() OVER (ORDER BY SUM(amount) DESC) AS revenue_rank
FROM transactions
GROUP BY customer_id
ORDER BY total_revenue DESC;
-- The above query calculates the total revenue generated by each customer and assigns a rank to each customer based on their total revenue in descending order. Customers with the same total revenue receive the same rank, and the next rank is incremented accordingly.
```

![My Project Screenshot](/screenshots/rank.png)
```sql
--dense_rank()

SELECT customer_id,
       SUM(amount) AS total_revenue,
       DENSE_RANK() OVER (ORDER BY SUM(amount) DESC) AS dense_rank
FROM transactions
GROUP BY customer_id
ORDER BY total_revenue DESC;
-- The above query calculates the total revenue generated by each customer and assigns a dense rank to each customer based on their total revenue in descending order. Customers with the same total revenue receive the same rank, and the next rank is not skipped.
```
![My Project Screenshot](/screenshots/danse_rank.png)
```sql
--percent_rank()
SELECT customer_id,
       SUM(amount) AS total_revenue,
       PERCENT_RANK() OVER (ORDER BY SUM(amount) DESC) AS percent_rank
FROM transactions
GROUP BY customer_id
ORDER BY total_revenue DESC;
-- The above query calculates the total revenue generated by each customer and assigns a percent rank to each customer based on their total revenue in descending order. The percent rank indicates the relative standing of each customer within the group, ranging from 0 to 1.
```
![My Project Screenshot](/screenshots/percent_rank.png)

2. Aggregate Functions
```sql
--sum(), 
SELECT transaction_id,
       sale_date,
       amount,
       SUM(amount) OVER (ORDER BY sale_date) AS running_total
FROM transactions
ORDER BY sale_date;
-- The above query calculates a running total of the amount for each transaction ordered by the sale date. The SUM() function is used as a window function to compute the cumulative sum of the amount column up to the current row, providing a running total that updates with each transaction in chronological order.
```
![My Project Screenshot](/screenshots/sum1.png)

```sql
--average(),

SELECT transaction_id,
       sale_date,
       amount,
       AVG(amount) OVER (ORDER BY sale_date) AS running_avg
FROM transactions
ORDER BY sale_date;
-- The above query calculates a running average of the amount for each transaction ordered by the sale date. The AVG() function is used as a window function to compute the cumulative average of the amount column up to the current row, providing a running average that updates with each transaction in chronological order.
```
![My Project Screenshot](/screenshots/average1.png)

```sql
--minimum(),
SELECT transaction_id,
       sale_date,
       amount,
       MIN(amount) OVER (ORDER BY sale_date) AS min_so_far
FROM transactions
ORDER BY sale_date;
-- The above query calculates the minimum amount encountered so far for each transaction ordered by the sale date. The MIN() function is used as a window function to compute the cumulative minimum of the amount column up to the current row, providing a running minimum that updates with each transaction in chronological order.
```
![My Project Screenshot](/screenshots/min1.png)

```sql
--maximum(),
SELECT transaction_id,
       sale_date,
       amount,
       MAX(amount) OVER (ORDER BY sale_date) AS max_so_far
FROM transactions
ORDER BY sale_date;
-- The above query calculates the maximum amount encountered so far for each transaction ordered by the sale date. The MAX() function is used as a window function to compute the cumulative maximum of the amount column up to the current row, providing a running maximum that updates with each transaction in chronological order.
```
![My Project Screenshot](/screenshots/max1.png)

3. Navigation Functions
   
```sql
--lag(),
SELECT transaction_id,
       sale_date,
       amount,
       LAG(amount) OVER (ORDER BY sale_date) AS prev_amount
FROM transactions
ORDER BY sale_date;
-- The above query retrieves the previous amount for each transaction ordered by the sale date. The LAG() function is used as a window function to access the amount from the previous row in the ordered set, allowing for comparison between the current and previous transaction amounts.
```
![My Project Screenshot](/screenshots/lag.png)

```sql
--lead(),
SELECT transaction_id,
       sale_date,
       amount,
       LEAD(amount) OVER (ORDER BY sale_date) AS next_amount
FROM transactions
ORDER BY sale_date;
-- The above query retrieves the next amount for each transaction ordered by the sale date. The LEAD() function is used as a window function to access the amount from the next row in the ordered set, allowing for comparison between the current and next transaction amounts.
```
![My Project Screenshot](/screenshots/lead.png)

4. Distribution Functions
```sql
--ntile(),
SELECT customer_id,
       SUM(amount) AS total_revenue,
       NTILE(4) OVER (ORDER BY SUM(amount) DESC) AS revenue_quartile
FROM transactions
GROUP BY customer_id
ORDER BY total_revenue DESC;
-- The above query calculates the total revenue generated by each customer and divides the customers into four quartiles based on their total revenue in descending order. The NTILE(4) function is used as a window function to assign each customer to one of the four quartiles, with 1 representing the highest quartile and 4 representing the lowest quartile.
```
![My Project Screenshot](/screenshots/ntile.png)

```sql
--cume_dist()
SELECT customer_id,
       SUM(amount) AS total_revenue,
       CUME_DIST() OVER (ORDER BY SUM(amount) DESC) AS revenue_distribution
FROM transactions
GROUP BY customer_id
ORDER BY total_revenue DESC;
-- The above query calculates the total revenue generated by each customer and computes the cumulative distribution of customers based on their total revenue in descending order. The CUME_DIST() function is used as a window function to determine the relative standing of each customer within the group, indicating the proportion of customers with total revenue less than or equal to the current customer's total revenue.
```
![My Project Screenshot](/screenshots/cume_dist.png)


RESULTS ANALYSIS
 
1.Descriptive

Top customers contribute the majority of sales revenue.

Coffee and Beans are frequent top sellers.

Sales increased steadily across multiple months.

2.Diagnostic

Kigali and Rubavu customers dominate sales due to larger populations.

Seasonal demand drives fluctuations in fruits and beverages.

3.Prescriptive

Increase stock of top-selling products.

Launch promotions for low-spending customers.

Plan seasonal campaigns based on product demand cycles.
