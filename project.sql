create table customers(customer_id int primary key, cust_name varchar(50), region varchar(30));

create table products(product_id int primary key, prod_name varchar(50), category varchar(40));



create table transactions (transaction_id int primary key, customer_id int , foreign key (customer_id) references customers (customer_id), product_id int, foreign key (product_id) references products(product_id), sale_date date, amount decimal(10, 2));

insert into customers values ( 1,'yabesi','musanze');
insert into customers values ( 2,'niyonkuru','rubavu');
insert into customers values ( 3,'nyirimpeta','gasabo');
insert into customers values ( 4,'rukundo','kicikoro');
insert into customers values ( 5,'shema','nyabihu');
insert into customers values ( 6,'ruterana','nyabihu');
insert into customers values ( 7,'iduhorahafi','remera');
insert into customers values ( 8,'niyomugaba','kimironko');
insert into customers values ( 9,'uwase','rubavu');
insert into customers values ( 10,'uwera','gakenke');


insert into products values(1, 'beans', 'lugumes');
insert into products values(2, 'oranges', 'fruits');
insert into products values(3, 'carrots', 'vagetable');
insert into products values(4, 'coffee', 'cash crops');
insert into products values(5, 'milk', 'livestock');
insert into products values(6, 'flowers', 'horticulture');
insert into products values(7, 'tea', 'cash crops');
insert into products values(8, 'onions', 'vegetables');
insert into products values(9, 'bananas', 'fruits');
insert into products values(10, 'rice', 'cereals');


insert into transactions values(1, 1,1, '2025-01-03', 12000);
insert into transactions values(2, 3,4, '2025-04-13', 12400);
insert into transactions values(3, 5,7, '2025-05-09', 17800);
insert into transactions values(4, 8,2, '2025-09-09', 20000);
insert into transactions values(5, 9,8, '2025-07-03', 25000);
insert into transactions values(6, 5,4, '2025-02-20', 27000);
insert into transactions values(7, 1,9, '2025-03-15', 10000);
insert into transactions values(8, 4,8, '2025-01-10', 8000);
insert into transactions values(9, 10,1, '2025-01-10', 8000);
insert into transactions values(10, 10,10, '2025-10-10',100000);


-- window functions implementation

-- 1.ranking functions

--row_number(),
SELECT customer_id,
       SUM(amount) AS total_revenue,
       ROW_NUMBER() OVER (ORDER BY SUM(amount) DESC) AS row_num
FROM transactions
GROUP BY customer_id
ORDER BY total_revenue DESC;
-- The above query calculates the total revenue generated by each customer and assigns a unique row number to each customer based on their total revenue in descending order.

--rank(),

SELECT customer_id,
       SUM(amount) AS total_revenue,
       RANK() OVER (ORDER BY SUM(amount) DESC) AS revenue_rank
FROM transactions
GROUP BY customer_id
ORDER BY total_revenue DESC;
-- The above query calculates the total revenue generated by each customer and assigns a rank to each customer based on their total revenue in descending order. Customers with the same total revenue receive the same rank, and the next rank is incremented accordingly.


--dense_rank()

SELECT customer_id,
       SUM(amount) AS total_revenue,
       DENSE_RANK() OVER (ORDER BY SUM(amount) DESC) AS dense_rank
FROM transactions
GROUP BY customer_id
ORDER BY total_revenue DESC;
-- The above query calculates the total revenue generated by each customer and assigns a dense rank to each customer based on their total revenue in descending order. Customers with the same total revenue receive the same rank, and the next rank is not skipped.

--percent_rank()
SELECT customer_id,
       SUM(amount) AS total_revenue,
       PERCENT_RANK() OVER (ORDER BY SUM(amount) DESC) AS percent_rank
FROM transactions
GROUP BY customer_id
ORDER BY total_revenue DESC;
-- The above query calculates the total revenue generated by each customer and assigns a percent rank to each customer based on their total revenue in descending order. The percent rank indicates the relative standing of each customer within the group, ranging from 0 to 1.


-- 2.aggregate functions with window functions

--sum(), 
SELECT transaction_id,
       sale_date,
       amount,
       SUM(amount) OVER (ORDER BY sale_date) AS running_total
FROM transactions
ORDER BY sale_date;
-- The above query calculates a running total of the amount for each transaction ordered by the sale date. The SUM() function is used as a window function to compute the cumulative sum of the amount column up to the current row, providing a running total that updates with each transaction in chronological order.

--average(),

SELECT transaction_id,
       sale_date,
       amount,
       AVG(amount) OVER (ORDER BY sale_date) AS running_avg
FROM transactions
ORDER BY sale_date;
-- The above query calculates a running average of the amount for each transaction ordered by the sale date. The AVG() function is used as a window function to compute the cumulative average of the amount column up to the current row, providing a running average that updates with each transaction in chronological order.

--minimum(),
SELECT transaction_id,
       sale_date,
       amount,
       MIN(amount) OVER (ORDER BY sale_date) AS min_so_far
FROM transactions
ORDER BY sale_date;
-- The above query calculates the minimum amount encountered so far for each transaction ordered by the sale date. The MIN() function is used as a window function to compute the cumulative minimum of the amount column up to the current row, providing a running minimum that updates with each transaction in chronological order.

--maximum(),

SELECT transaction_id,
       sale_date,
       amount,
       MAX(amount) OVER (ORDER BY sale_date) AS max_so_far
FROM transactions
ORDER BY sale_date;
-- The above query calculates the maximum amount encountered so far for each transaction ordered by the sale date. The MAX() function is used as a window function to compute the cumulative maximum of the amount column up to the current row, providing a running maximum that updates with each transaction in chronological order.


--3.navigational functions
--lag(),

SELECT transaction_id,
       sale_date,
       amount,
       LAG(amount) OVER (ORDER BY sale_date) AS prev_amount
FROM transactions
ORDER BY sale_date;
-- The above query retrieves the previous amount for each transaction ordered by the sale date. The LAG() function is used as a window function to access the amount from the previous row in the ordered set, allowing for comparison between the current and previous transaction amounts.

--lead(),

SELECT transaction_id,
       sale_date,
       amount,
       LEAD(amount) OVER (ORDER BY sale_date) AS next_amount
FROM transactions
ORDER BY sale_date;
-- The above query retrieves the next amount for each transaction ordered by the sale date. The LEAD() function is used as a window function to access the amount from the next row in the ordered set, allowing for comparison between the current and next transaction amounts.


--4.distribution functions

--ntile(),
SELECT customer_id,
       SUM(amount) AS total_revenue,
       NTILE(4) OVER (ORDER BY SUM(amount) DESC) AS revenue_quartile
FROM transactions
GROUP BY customer_id
ORDER BY total_revenue DESC;
-- The above query calculates the total revenue generated by each customer and divides the customers into four quartiles based on their total revenue in descending order. The NTILE(4) function is used as a window function to assign each customer to one of the four quartiles, with 1 representing the highest quartile and 4 representing the lowest quartile.

--cume_dist()
SELECT customer_id,
       SUM(amount) AS total_revenue,
       CUME_DIST() OVER (ORDER BY SUM(amount) DESC) AS revenue_distribution
FROM transactions
GROUP BY customer_id
ORDER BY total_revenue DESC;
-- The above query calculates the total revenue generated by each customer and computes the cumulative distribution of customers based on their total revenue in descending order. The CUME_DIST() function is used as a window function to determine the relative standing of each customer within the group, indicating the proportion of customers with total revenue less than or equal to the current customer's total revenue.
